#!/bin/bash

script_preamble() {
    local lua_args=$(lua5.3 -e 'io.stdout:write "{"; for i = 1, #arg do io.stdout:write(string.format("%q, ", arg[i])) end; io.stdout:write "}"' - "$@" </dev/null)

    cat <<END_LUA
local __print_lines = {}

local function print(...)
  local nargs = select('#', ...)
  local line_chunks = {}
  for i = 1, nargs do
    local arg = select(i, ...)
    line_chunks[i] = tostring(arg)
  end
    __print_lines[#__print_lines + 1] = table.concat(line_chunks, ' ')
end

local require

do
  local __inline_module_loaders = {}
  local __inline_modules = {}

  --[[ local ]] function require(modname)
    local module = __inline_modules[modname]
    if module then
      return module
    end

    local loader = __inline_module_loaders[modname]
    if not loader then
      error(string.format('module %q not found', modname))
    end

    module = loader()
    __inline_modules[modname] = module
    return module
  end

END_LUA

    for filename in lib/*.lua ; do
        module_name="$filename"
        module_name="${module_name##lib/}"
        module_name="${module_name%%.lua}"
        module_name="${module_name//\//.}"

        # XXX something like a #line directive would be nice
        echo "-- $filename"
        echo "__inline_module_loaders[ [[$module_name]] ] = function()"
        cat "$filename"
        echo 'end'
        echo ''
    done

    cat <<END_LUA
end

local ok, err = xpcall(function()
local arg = $lua_args
END_LUA
}

script_postamble() {
    cat <<END_LUA
end, debug.traceback)

if err then
  print(string.format("script threw an error: %s", err))
end

return '\\n' .. table.concat(__print_lines, '\\n') .. '\\n'
END_LUA
}

script_name="$1"
shift

# XXX pipe to dbus-send instead?

( script_preamble "$@" ; cat "$script_name" ; script_postamble ) | awesome-client | tail -n +2 | head -n -1
